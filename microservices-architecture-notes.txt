##1##
-----
Microservices are ideal for big systems
Microservice architecture is goal-oriented
Microservices are focused on replaceability

At the end of our three-day meeting, one of us called out a theme—that year it had been clear that many of the problems people were facing in the wild were related to building systems that were too big. “How can I rebuild a part of this,” “best ways to implement Strangler,” etc.
Turning that on its head, the problem became “how can we build systems that are replaceable over being maintainable?”
We used the term micro apps, I seem to remember.
—James Lewis

Microservices are small, autonomous services that work together.
—Sam Newman, Thoughtworks

Loosely coupled service-oriented architecture with bounded contexts.
—Adrian Cockcroft, Battery Ventures

A microservice is an independently deployable component of bounded scope that supports interoperability through message-based communication.
Microservice architecture is a style of engineering highly automated, evolvable software systems made up of capability-aligned microservices.
-Martin Fowler

microservice applications share some important characteristics:
• Small in size
• Messaging enabled
• Bounded by contexts
• Autonomously developed
• Independently deployable
• Decentralized
• Built and released with automated processes

Speed and Safety at Scale and in Harmony.
—The Microservices Way

* Speed of Change: Most organizations have the platforms, tools, and infrastructure in place to implement thousands of application releases within a single day. But they don’t. In fact, most teams are happy if they can manage a release in a week. Why is that? The answer of course is that the real deterrent to release speed is the fragility of the software they’ve produced.
* Safety of Change: Every change is potentially a breaking change and a system optimized purely for speed is only realistic if the cost of breaking the system is near zero. Most development environments are optimized for release speed, enabling the software developer to make multiple changes in as short a time as possible. On the other hand, most production environments are optimized for safety, restricting the rate of change to those releases that carry the minimum risk of damage.
* At Scale: microservices style is rooted in the idea of solving the problems that arise when software gets too big. To build at scale means to build software that can continue to work when demand grows beyond our initial expectations. Systems that can work at scale don’t break when under pressure; instead they incorporate built-in mechanisms to increase capacity in a safe way.
* In Harmony: microservice architecture is not limited to a simple series of decisions regarding speed and safety of change. The microservices domain is actually fairly complex and will require you to understand a wide breadth of concepts that have a great depth of impact.

-----
##2##
-----
The greater the cohesion of individual modules in the system, the lower the coupling between modules will be.
—Larry Constantine and Edward Yourdon, authors of Structured Design: Funda‐ mentals of a Discipline of Computer Program and Systems Design

The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.
—Alan Kay, 1998 email to the Squeak-dev list (http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html)

Dealing with complex systems requires a careful approach based on influence versus control

-----
##3##
-----
The very first step of a service design process is to design the process itself.
—Marc Stickdorn, author of This is Service Design Thinking

Bad designers make assumptions about how a system works, apply changes in the hope that it will produce desired behavior, and call it a day. Good designers make small system changes, assess the impact of those changes, and continually prod the system behavior toward a desired outcome. But a good design process is predicated on your ability to get feedback from the system you are designing. This is actually much more difficult than it sounds—the impact of a change to one small part of the system may result in a ripple of changes that impact other parts of your system with low visibility.
Gain essential visibility into our system by identifying a few key measurements that give us the most valuable information about system behavior. In organizational design, this type of metric is known as a key performance indicator (KPI). The challenge for the microservice designer is to identify the right ones.
The risk of making poor decisions is that we steer the system in a direction that increases our “technical debt” (i.e., the future cost of addressing a technical defi‐ ciency). If we go too far along the wrong path we risk producing a system that becomes too expensive to change, so we give up.

The classic microservices example of this is the cautionary tale of the “monolith.” A team creates an initial release of an application when the feature set is small and the componentry has low complexity. Over time, the feature set grows and the complex‐ ity of the deployed application grows, making change ever more difficult. At this point, the team agrees that the application needs to be redesigned and modularized to improve its changeability. But the redesign work is continually deferred because the cost of that work is too high and difficult to justify.
At the other end of the scale is a system that is so overdesigned and overengineered for future flexibility that it becomes impractical. An incredibly complex, adaptable system that is built for massive amounts of change that never seems to happen.
So, in order to design a microservice system that is dynamic you’ll need to identify the right KPIs, be able to interpret the data, and make small, cheap changes to the system that can guide you back on the right course. This is only possible if the right organization, culture, processes, and system architecture are in place to make it cheap and easy to do so.

-----
##4##
-----
Goals for the Microservices Way
From our research, we’ve been able to distill four specific goals that lead to practices that aid both safety and speed of change.
These goals aren’t unique to microservice architecture, but they are useful in shaping your journey.
Here are the four goals to consider:
1. Reduce Cost: Will this reduce overall cost of designing, implementing, and maintaining IT services?
2. Increase Release Speed: Will this increase the speed at which my team can get from idea to deployment of services?
3. Improve Resilience: Will this improve the resilience of our service network?
4. Enable Visibility: Does this help me better see what is going on in my service network
Trade-off for all these four.

Operating Principles
Along with a set of goals for a microservice approach, it is important to have a set of principles. Unlike goals, which are general, principles offer more concrete guidance on how to act in order to achieve those goals. Principles are not rules—they don’t set out required elements. Instead, they offer examples on how to act in identifiable situa‐ tions. Principles can also be used to inform best practices. Many of the organizations we looked at when doing research have their own set of principles within their company.

Netflix operating principles:
- Antifragility: The point of antifragility is that you always want a bit of stress in your system to make it stronger. Simian Army.
- Immutability: assert that auto- scaled groups of service instances are stateless and identical, which enables Netflix’s system to “scale horizontally.” The Chaos Monkey, removes instances regularly to enforce the immutable stateless service principle.
Another related technique is the use of “Red/Black pushes”. Although each released component is immutable, a new version of the service is introduced alongside the old version, on new instances, then traffic is redirected from old to new. After waiting to be sure all is well, the old instances are terminated.
- Separation of Concerns: The Netflix microservice architecture arises because of separation of concerns (SoC) in the engineering team organization. Each team owns a group of services. They own building, operating, and evolving those services, and present a stable agreed interface and service level agreement to the consumers of those services. Invoking Conway’s law, an organization structured with independent self- contained cells of engineers will naturally build what is now called a microservice architecture.

-----------
## Links ##
-----------
Links linked for shis book: https://github.com/apiacademy/MSABook

Four principles of low risk sofware releases: https://www.informit.com/articles/article.aspx?p=1833567

“If it moves graph it. If it matters, alert on it”.: https://www.slideshare.net/jallspaw/dev-and-ops-collaboration-and-awareness-at-etsy-and-flickr/32-Maintainability_Versus_MTTR_Optimized_MTBF

https://www.slideshare.net/adrianco
https://slides.yowconference.com/yow2013/Cockcroft-CloudNativeArchitectureNetflix.pdf
https://www.slideshare.net/adriancockcroft

The Netflix Simian Army: https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116

---------
## Cit ##
---------
Gall's Law: A complex system that works is invariably found to have evolved from a simple system that worked (which bring us to "Monolith first")

-----------
## Books ##
-----------
The End of Average by Todd Rose (Harper Collins, 2016). Rose has given a TEDx talk on the subject of averages and is a leading proponent of an interdisciplinary field called “The Science of the Individual”.

Structure in Fives by Henry Mintzberg (organizational designer)

