##1##
-----
Microservices are ideal for big systems
Microservice architecture is goal-oriented
Microservices are focused on replaceability

At the end of our three-day meeting, one of us called out a theme—that year it had been clear that many of the problems people were facing in the wild were related to building systems that were too big. “How can I rebuild a part of this,” “best ways to implement Strangler,” etc.
Turning that on its head, the problem became “how can we build systems that are replaceable over being maintainable?”
We used the term micro apps, I seem to remember.
—James Lewis

Microservices are small, autonomous services that work together.
—Sam Newman, Thoughtworks

Loosely coupled service-oriented architecture with bounded contexts.
—Adrian Cockcroft, Battery Ventures

A microservice is an independently deployable component of bounded scope that supports interoperability through message-based communication.
Microservice architecture is a style of engineering highly automated, evolvable software systems made up of capability-aligned microservices.
-Martin Fowler

microservice applications share some important characteristics:
• Small in size
• Messaging enabled
• Bounded by contexts
• Autonomously developed
• Independently deployable
• Decentralized
• Built and released with automated processes

Speed and Safety at Scale and in Harmony.
—The Microservices Way

* Speed of Change: Most organizations have the platforms, tools, and infrastructure in place to implement thousands of application releases within a single day. But they don’t. In fact, most teams are happy if they can manage a release in a week. Why is that? The answer of course is that the real deterrent to release speed is the fragility of the software they’ve produced.
* Safety of Change: Every change is potentially a breaking change and a system optimized purely for speed is only realistic if the cost of breaking the system is near zero. Most development environments are optimized for release speed, enabling the software developer to make multiple changes in as short a time as possible. On the other hand, most production environments are optimized for safety, restricting the rate of change to those releases that carry the minimum risk of damage.
* At Scale: microservices style is rooted in the idea of solving the problems that arise when software gets too big. To build at scale means to build software that can continue to work when demand grows beyond our initial expectations. Systems that can work at scale don’t break when under pressure; instead they incorporate built-in mechanisms to increase capacity in a safe way.
* In Harmony: microservice architecture is not limited to a simple series of decisions regarding speed and safety of change. The microservices domain is actually fairly complex and will require you to understand a wide breadth of concepts that have a great depth of impact.

-----
##2##
-----
The greater the cohesion of individual modules in the system, the lower the coupling between modules will be.
—Larry Constantine and Edward Yourdon, authors of Structured Design: Funda‐ mentals of a Discipline of Computer Program and Systems Design

The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.
—Alan Kay, 1998 email to the Squeak-dev list (http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html)

Dealing with complex systems requires a careful approach based on influence versus control

-----
##3##
-----
The very first step of a service design process is to design the process itself.
—Marc Stickdorn, author of This is Service Design Thinking

Bad designers make assumptions about how a system works, apply changes in the hope that it will produce desired behavior, and call it a day. Good designers make small system changes, assess the impact of those changes, and continually prod the system behavior toward a desired outcome. But a good design process is predicated on your ability to get feedback from the system you are designing. This is actually much more difficult than it sounds—the impact of a change to one small part of the system may result in a ripple of changes that impact other parts of your system with low visibility.
Gain essential visibility into our system by identifying a few key measurements that give us the most valuable information about system behavior. In organizational design, this type of metric is known as a key performance indicator (KPI). The challenge for the microservice designer is to identify the right ones.
The risk of making poor decisions is that we steer the system in a direction that increases our “technical debt” (i.e., the future cost of addressing a technical defi‐ ciency). If we go too far along the wrong path we risk producing a system that becomes too expensive to change, so we give up.

The classic microservices example of this is the cautionary tale of the “monolith.” A team creates an initial release of an application when the feature set is small and the componentry has low complexity. Over time, the feature set grows and the complex‐ ity of the deployed application grows, making change ever more difficult. At this point, the team agrees that the application needs to be redesigned and modularized to improve its changeability. But the redesign work is continually deferred because the cost of that work is too high and difficult to justify.
At the other end of the scale is a system that is so overdesigned and overengineered for future flexibility that it becomes impractical. An incredibly complex, adaptable system that is built for massive amounts of change that never seems to happen.
So, in order to design a microservice system that is dynamic you’ll need to identify the right KPIs, be able to interpret the data, and make small, cheap changes to the system that can guide you back on the right course. This is only possible if the right organization, culture, processes, and system architecture are in place to make it cheap and easy to do so.

-----
##4##
-----
Goals for the Microservices Way
From our research, we’ve been able to distill four specific goals that lead to practices that aid both safety and speed of change.
These goals aren’t unique to microservice architecture, but they are useful in shaping your journey.
Here are the four goals to consider:
1. Reduce Cost: Will this reduce overall cost of designing, implementing, and maintaining IT services?
2. Increase Release Speed: Will this increase the speed at which my team can get from idea to deployment of services?
3. Improve Resilience: Will this improve the resilience of our service network?
4. Enable Visibility: Does this help me better see what is going on in my service network
Trade-off for all these four.

Operating Principles
Along with a set of goals for a microservice approach, it is important to have a set of principles. Unlike goals, which are general, principles offer more concrete guidance on how to act in order to achieve those goals. Principles are not rules—they don’t set out required elements. Instead, they offer examples on how to act in identifiable situa‐ tions. Principles can also be used to inform best practices. Many of the organizations we looked at when doing research have their own set of principles within their company.

Netflix operating principles:
- Antifragility: The point of antifragility is that you always want a bit of stress in your system to make it stronger. Simian Army.
- Immutability: assert that auto- scaled groups of service instances are stateless and identical, which enables Netflix’s system to “scale horizontally.” The Chaos Monkey, removes instances regularly to enforce the immutable stateless service principle.
Another related technique is the use of “Red/Black pushes”. Although each released component is immutable, a new version of the service is introduced alongside the old version, on new instances, then traffic is redirected from old to new. After waiting to be sure all is well, the old instances are terminated.
- Separation of Concerns: The Netflix microservice architecture arises because of separation of concerns (SoC) in the engineering team organization. Each team owns a group of services. They own building, operating, and evolving those services, and present a stable agreed interface and service level agreement to the consumers of those services. Invoking Conway’s law, an organization structured with independent self- contained cells of engineers will naturally build what is now called a microservice architecture.

Unix
A succinct set of software architecture principles appears in the foreword for the 1978 edition of Bell Labs’ “UNIX Timesharing System” documentation. The four points (listed next) were offered as a set of “maxims that have gained currency among the builders and users of the Unix system.”
Here is the list Douglas McIrloy and his colleagues called out:
1. Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new features.
2. Expect the output of every program to become the input to another, as yet unknown, program. Don’t clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don’t insist on interactive input.
3. Design and build software, even operating systems, to be tried early, ideally within weeks. Don’t hesitate to throw away the clumsy parts and rebuild them.
4. Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you’ve finished using them.
One of the interesting things about these four principles is that they offer general guidance on how to think about writing software. Phrases like “do one thing well” and “build software ... to be tried early” can lead developers to adopt what is known in the Unix world as “The Rule of Parsimony” when writing code (“only write a big program when nothing else will do”). This along with other Unix rules provides developers with a set of guidelines for which programming languages or libraries to use. These principles are also meant to shape developers’ thinking.

Suggested principles
There is no one set of principles that matches every company. Each organization needs to create a set that works for their company.
- Do one thing well
- Build afresh (something similar to Netflix immutability principle)
- Expect output to become input
- Don’t insist on interactive input: In the Unix world, there is a desire to create scripts that tie a number of command-line tools together to create a “solution.” This means humans don’t need to be engaged every step of the way the scripts handle both the input and the output on their own. Reducing the need for human interaction increases the likelihood that the component can be used in unexpected ways.
- Try early: The earlier you release (even when that release is to a test environment), the earlier you get feedback and the quicker you can improve.
- Don’t hesitate to throw it away: However, when you adopt the “try early” principle, throwing away the early attempts is easier.
It is also important to consider this “throw it away” principle for components that have been running in production for a long time. Over time, components that did an important job may no longer be needed. You may have applied the “build afresh” principle and replaced this component with one that does the job better. It may be the case that the “one thing” that component does is simply no longer needed. The important thing is to be willing to throw away a component when it no longer serves its intended purpose.
- Toolmaking: One of the important elements in the developmental history of humans was the ability to create tools. These tools were created in order to reach a goal. In some cases, you may need to divert from building your solution and spend some time building tools to help you build that solution.

Microservices concerns
- Shared capabilities (platform services that all teams use):
  - Hardware services
  - Code management, testing, and deployment
  - Data stores
  - Service Orchestration
  - Security and identity
  - Architectural policy
- Local capabilities (selected and maintained at the team or group level to help teams become more self-sufficient):
  - General tooling
  - Runtime configuration (Twitter's Decider | Facebook's Gatekeeper)
  - Service discovery (Zookeeper | etcd | Consul)
  - Request routing (Zuul | Netty | Finagle)
  - System observability (Zipkin | Hystrix)
- Culture (The code your team produces is the result of the culture)
  - Communication
  - Team alignment (The Mythical Man Month | 2-pizza team | squad&tribe)
  - Fostering innovation (setting boundaries that prevent teams from taking actions that threaten the health and welfare of the company and allowing teams to act on their own within these safe boundaries)


-------------------------------------------------
Microservices in practice
##5##

-----------
## Links ##
-----------
Links linked for shis book: https://github.com/apiacademy/MSABook

Four principles of low risk sofware releases: https://www.informit.com/articles/article.aspx?p=1833567

“If it moves graph it. If it matters, alert on it”.: https://www.slideshare.net/jallspaw/dev-and-ops-collaboration-and-awareness-at-etsy-and-flickr/32-Maintainability_Versus_MTTR_Optimized_MTBF

https://www.slideshare.net/adrianco
https://slides.yowconference.com/yow2013/Cockcroft-CloudNativeArchitectureNetflix.pdf
https://www.slideshare.net/adriancockcroft

The Netflix Simian Army: https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116

State of the art in microservices (2014): https://www.slideshare.net/adriancockcroft/dockercon-state-of-the-art-in-microservices

Twitter's Decider configuration tool: https://www.infoq.com/articles/twitter-infrastructure/
Facebook's Gatekeeper: http://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf

Circuit Braker: https://martinfowler.com/bliki/CircuitBreaker.html

Why we do it the way we do it: https://www.slideshare.net/dev2ops/you-cant-change-culture-but-you-can-change-behavior-and-behavior-becomes-culture

Netflix context, not control: https://www.linkedin.com/pulse/netflixs-context-control-how-does-work-steve-urban

---------
## Cit ##
---------
Gall's Law: A complex system that works is invariably found to have evolved from a simple system that worked (which bring us to "Monolith first")

You build it, you run it.
—Werner Vogels, Amazon CTO
In small organizations, it is likely that the local capability elements will be the same for the entire company (e.g., the small startup is just a single team anyway). However, as the company grows, acquires new products, and expands into new technology and mar‐ ket spaces, forcing everyone to continue to use the same developer tools, routing implementations, etc., does not scale well. At that point, it makes sense to allow product groups to start making those decisions for themselves.

Organizations which design systems ... are constrained to produce designs that are copies of the communication structures of these organizations.
—Mel Conway, author of “How Do Committees Invent?”

I have neither the place, the time, nor the desire, to micromanage or make technical decisions for [my team].
—Steve Urban, Netflix engineer

-----------
## Books ##
-----------
The End of Average by Todd Rose (Harper Collins, 2016). Rose has given a TEDx talk on the subject of averages and is a leading proponent of an interdisciplinary field called “The Science of the Individual”.

Structure in Fives by Henry Mintzberg (organizational designer)

Grooming, Gossip and the evolution of language by Robin Dunbar (https://www.hup.harvard.edu/catalog.php?isbn=9780674363366)

-----------
## Tools ##
-----------
Morgue (Etsy post mortem tracing) https://github.com/etsy/morgue

Aminator (Netflix AMI creation tool) https://netflixtechblog.com/ami-creation-with-aminator-98d627ca37b0

Asgard (Web-based cloud management and depoyment) https://netflixtechblog.com/asgard-web-based-cloud-management-and-deployment-2c9fc4e4d3a1

etcd (key-value store for distributed systems) https://etcd.io/
