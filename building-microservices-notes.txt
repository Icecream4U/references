Strong cohesion and loose coupling

Any technology that pushes us to expose internal representation detail should be avoided. Share behaviour not representation.

Orchestration Versus Choreography

keep your middleware dumb, and keep the smarts in the endpoints

don’t violate DRY within a microservice, but be relaxed about violating DRY across all services. The evils of too much coupling between services are far worse than the problems caused by code duplication

----

Eventual consistency (local retry until it works) VS Distributed transaction (transaction manager -> 2 phase commit)

class-responsibility-collaboration (CRC) cards with services used as class

----

Avoid "configuration drift": the code in source control no longer reflects the configuration of the running host
We can resolve it with "Immutable servers"

----

A test suite with flaky tests can become a victim of what Diane Vaughan calls the normalization of deviance. The idea that over time we can become so accustomed to things being wrong that we start to accept them as being normal and not a problem 
(Diane Vaughan, The Challenger Launch Decision: Risky Technology, Culture, and Deviance at NASA (Chicago: University of Chicago Press, 1996))

The best balance I have found is to treat the end-to-end test suite as a shared codebase, but with joint ownership. Teams are free to check in to this suite, but the ownership of the health of the suite has to be shared between the teams developing the services themselves. If you want to make extensive use of end-to-end tests with multiple teams I think this approach is essential, and yet I have seen it done very rarely, and never without issue

Test Journeys, Not Stories -> Consumer driven Contracts

Using blue/green deployments to separate deployment from release: Deploy new versione -> run smoke test against it -> Redirect traffic

Canary releasing: we are verifying our newly deployed software by directing amounts of production traffic against the system to see if it performs as expected

Cross-functional requirements: Nonfunctional requirements is an umbrella term used to describe those characteristics your system exhibits that cannot simply be implemented like a normal feature. They include aspects like the acceptable latency of a web page, the number of users a system should support, how accessible your user interface should be to people with disabilities, or how secure your customer data should be.

----

there is an old adage that 80% of software features are never used. Now I can’t comment on how accurate that figure is, but as someone who has been developing software for nearly 20 years, I know that I have spent a lot of time on features that never actually get used. Wouldn’t it be nice to know what they are?
we are getting better than ever at reacting to how our users are using our system to work out how to improve it. Metrics that inform us of how our systems behave can only help us here. We push out a new version of the website, and find that the number of searches by genre has gone up significantly on the catalog service. Is that a problem, or expected?

synthetic transaction to enable semantic monitoring to better understand metrics before going on production

correlationsID (or Zipkin) to trace the results of an entry call in your system and all subsequent call the many services => mandatory in event-drive architecture patterns

be aware of the cascade: a service that go down and throws down every service that call it

With services collaborating in lots of different ways to provide capabilities to users using multiple interfaces, you need to view the system in a holistic way.
You should try to write your logs out in a standard format. You definitely want to have all your metrics in one place, and you may want to have a list of standard names for your metrics too; it would be very annoying for one service to have a metric called ResponseTime, and another to have one called RspTimeSecs, when they mean the same thing.

So why handle operational and business metrics in the same way? Ultimately, both types of things break down to events that say something happened at X. So, if we can unify the systems we use to gather, aggregate, and store these events, and make them available for reporting, we end up with a much simpler architecture.

----

Netflix designed the organizational structure for the system architecture it wanted.
Amazon's two-pizza teams, where no team should be so big that it could not be fed with two pizzas

-----------
## Links ##
-----------
DDD Bounded Context Explained: https://web.archive.org/web/20130101104734/http://www.sapiensworks.com/blog/post/2012/04/17/DDD-The-Bounded-Context-Explained.aspx

Richardson REST maturity model: https://martinfowler.com/articles/richardsonMaturityModel.html

Tolerant Reader: https://martinfowler.com/bliki/TolerantReader.html

Semantic versioning: https://semver.org/

Expand and contract pattern: https://martinfowler.com/bliki/ParallelChange.html

Strangler application pattern: https://martinfowler.com/bliki/StranglerFigApplication.html

Test doubles: https://www.martinfowler.com/bliki/TestDouble.html

Eradicating non determinism in tests: https://martinfowler.com/articles/nonDeterminism.html

Enterprise integration using REST: https://martinfowler.com/articles/enterpriseREST.html

Salted password hashing: https://crackstation.net/hashing-security.htm#properhashing

Fallacies of distributed computing: https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing

-----------
## Books ##
-----------
REST in Practice (O’Reilly)

Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions (Addison Wesley)

Working Effectively with Legacy Code

Refactoring Databases by Scott J. Ambler and Pramod J. Sadalage (Addison-Wesley)

Continuous Delivery by Jez Humble and Dave Farley 

Agile Testing by Lisa Crispin and Janet Gregory

Succeeding with Agile by Mike Cohn

Growing Object-Oriented Software, Guided by Tests, by Steve Freeman and Nat Pryce

Information Dashboard Design: Displaying Data for At-a-Glance Monitoring by Steven Few

Cryptography Engineering by Niels Ferguson, Bruce Schneier, and Tadayoshi Kohno

Exploring the Duality Between Product and Organizational Architectures

---------
## Cit ##
---------
Postel’s Law (otherwise known as the robustness principle): “Be conservative in what you do, be liberal in what you accept from others.” [https://tools.ietf.org/html/rfc761]

Melvin Conway’s paper How Do Committees Invent, published in Datamation maga‐ zine in April 1968, observed that:
Any organization that designs a system (defined more broadly here than just informa‐ tion systems) will inevitably produce a design whose structure is a copy of the organi‐ zation’s communication structure.
This statement is often quoted, in various forms, as Conway’s law. Eric S. Raymond summarized this phenomenon in The New Hacker’s Dictionary (MIT Press) by stating “If you have four groups working on a compiler, you’ll get a 4-pass compiler.”

-----------
## Tools ##
-----------
Structure 101
Schema spy: http://schemaspy.sourceforge.net/
https://www.packer.io/

Mountebank for test doubles: http://www.mbtest.org/

Pact (consumer-driven testing tool): https://docs.pact.io/

Zed attack proxy (ZAD): https://owasp.org/www-project-zap/


